# 测试开发理论补充

## 1. 软件开发流程

软件开发流程的演变
1. 传统瀑布模型
需求分析->设计->编码->实现->软件测试->完成->维护

优点：
- 开发的各个阶段比较清晰
- 强调早期计划及需求调查
- 适合需求稳定的产品开发
缺点：
- 由于开发模型是线性的，增加了开发的风险
- 早期的错误可能要等到开发后期的阶段才能发现

2. 敏捷开发模型
总结：增量迭代，小步快跑

- XP（极限编程）
编程方法->小组实践->交付和管理

- SCRUM
产品BACKLOG->SPRINT计划会议->SPRINT BACKLOG->2到4周SPRINT

3. DevOps开发模型
DevOps:Development(Software Engineering)+Quality Assurance(QA)+Technology Operations

持续开发->持续测试->持续集成->持续部署->持续监控

持续集成（Continuous integration，缩写为CI）是一种软件开发实践，即团队开发成员经常集成他们的
工作，通常每个成员每天至少集成一次，也就以为着每天可能发生多次集成。每次集成都通过自动化的构建（包
括编译，发布，自动化测试）来认证，根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。

持续交付（Continuous delivery，缩写为CD）是一种软件工程手法，让软件产品的产出过程在一个短周期内完
成，以保证软件可以稳定、持续的保持在随时可以发布的状况。它的目标在于让软件的构建、测试与发布变得更快以
及更频繁。这种方式可以减少软件开发的成本与时间，减少风险。

- CD与DevOps的关系
```
1. DevOps的范围更广，是软件交付过程所设计的多个团队之间的合作，并且将软件交付的过程自动化。
2. 持续交付是一种自动化交付的手段，关注点在于将不同的过程集中起来，并且更快、更频繁地执行这些过程。
3. DevOps可以是持续交付下的一个产物，持续交付的成果直接汇入DevOps模型
```

## 2. 被测系统的架构与数据流分析
如何快速了解一家公司的架构
1. 业务流程：
- 商业模式
- 业务数据：角色、资源、数据
- 业务流程：角色、行为、数据的集成关系

2. 系统架构
- 架构角色与技术栈：
	网关：apache/nginx/f5
	应用开发：spring boot/spring cloud
	通讯协议：dubbo/http/pb
	数据处理：hadoop/spark/flink
	数据存储：redis/mysql/oracle/redis/es
	文档存储：mongodb/hbase/neo4j
- 部署架构：架构角色的集成关系：

统一建模语言UML
- 用例图：商业模式、业务角色
- 时序图：业务流程、调用关系
- 部署图：系统架构与集成关系
- 活动图：业务逻辑分析

推荐工具
- plantuml
- yed
- draw.io
- processon
- visio

测试用例设计总结
- 使用用例图分析角色与资源
- 使用思维导图分析功能点
- 使用时序图分析数据流
- 使用活动图分析业务逻辑

## 3. 被测需求理解
1. 需求文档

2. 需求评审
- 业务场景角度
用户故事
业务流程图

- 功能点角度
数据约束是否全面、合理
存在分支的逻辑、描述是否覆盖所有路径
多状态流程，状态流转描述是否合理且完整
权限描述是否明确

3. 需求分析
明确测试范围
明确功能点
明确业务流程
明确输出结果
分析异常流程
预估测试需要的时间和资源

## 4. 项目管理与跨部门沟通协作
1. 项目管理
项目流程：
项目立项->产品定义->软件开发->软件测试->内部验收->用户验收->系统维护

软件开发与测试细分：
```
需求分析阶段->概要设计阶段->详细设计阶段->系统编码阶段->单元测试阶段->集成测试阶段->系统测试阶段
```

完整的项目过程：
```
项目管理过程
评审过程
软件监督与审核过程
软件配置管理过程
软件需求管理过程
变更控制过规程
文档控制规程
文档开发与管理规范
```

软件项目管理的方法：
执行项目计划->执行该计划并监控跟踪管理->项目风险应对与问题解决->项目收尾

2. 跨部门沟通协作
- 与产品沟通
需求评审会
在分析需求阶段
在测试用例编写阶段
在测试过程中

- 与开发沟通
在分析需求阶段
在测试用例编写阶段
在测试过程中
在线上监控发现bug时

- 上下游测试配合
测试计划沟通
环境对接
熟悉业务

## 5. 流程管理平台
1. JIRA管理平台
JIRA中的基本概念：
```
Project项目
Issue问题
Field字段
Workflow工作流
Screen视图
```

2. JIRA平台管理测试流程
- 1. 创建测试用例管理项目
- 2. 录入用例
- 3. 测试用例状态转化

JIRA管理Bug流程：
创建Bug管理项目
从用例关联到Bug
在项目中录入Bug
Bug状态转化

## 6. 测试流程体系
1. 软件测试基本概念
- 基本概念
通过手工或者工具对“被测对象”进行测试
验证实际结果与预期结果之间是否存在差异

- 软件测试作用
通过测试工作可以发现并修复软件当中存在的缺陷，从而提高用户对产品的
使用信心
测试可以降低同类型产品开发遇到问题的风险

- 软件缺陷
软件缺陷被测试工程师和开发工程师们称为bug
软件缺陷会导致软件不能正常运行，它的存在会在一定程度上导致软件不能满
足用户的需求，甚至有可能破坏或泄漏用户的重要数据

- 软件测试原则
测试显示缺陷的存在
穷尽测试是不可能的
测试尽早介入
缺陷集群性（2/8原则）
杀虫剂悖论
测试活动依赖于测试内容
没有错误是好是谬论

- 软件测试对象
需求分析阶段：需求文档、接口文档
编码实现阶段：源代码
系统功能使用：软件程序

- 测试用例
为特定的目的而设计的一组测试输入、执行步骤和预期的结果，以便测试产品是否满足某个特定需求的文档

2. 软件测试模型
- V模型
V模型是瀑布模型的一种改进
V模型标明了测试过程中的不同阶段
需求分析->概要设计->详细设计->编码->单元测试->集成测试->系统测试->验收测试

V模型详细步骤：
```
需求分析：需求文档
概要设计：系统架构、模块划分、模块与模块之间的接口
详细设计：模块内部实现的逻辑和方法
编码：用代码实现设计的内容
单元测试：测试代码中最小模块是否符合详细设计
集成测试：测试各个模块组成到一起后是否可以正常使用
系统测试：测试已经集成在一起的产品是否符合需求文档中的要求
验收测试：测试产品是否符合用户的需求
```

V模型的优缺点：
```
优点：
既有底层测试又有高层测试。
将开发阶段清楚的表现出来，便于控制开发的过程。

缺点：
容易让人误解为测试是在开发完成之后的一个阶段。
由于它的顺序性，当编码完成之后，正式进入测试时，这时发现的一些Bug可能
不容易找到其根源，并且代码修改起来很困难。
如果需求变更较大，导致要重复变更需求、设计、编码、测试。返工量大。
```

- W模型
W模型明确表示出了测试与开发的并行关系
W模型中测试伴随着整个软件开发周期，并且测试的对象不仅仅是程序，需求和
设计同样要测试
```
测试与开发并行
用户需求->需求分析->概要设计->详细设计->编码->集成->实施->交付
验收测试设计-确认与系统测试设计->集成测试设计->单元测试设计->单元测试->
集成测试->确认测试&系统测试->验收测试
```

W模型的优缺点
```
优点：
将测试贯穿到整个软件的生命周期中，且除了代码要测试，需求、设计等都要测试。
更早的介入到软件开发中，能尽早的发现缺陷进行修复。
测试与开发独立起来，并与开发并行。

缺点：
无法支持迭代的开发模型。
对有些项目，开发过程中根本没有文档产生，故W模型无法使用。
对于需求和设计的测试技术要求很高，实践起来很困难。
```

- H模型
软件开发中需求、设计、编码等活动被分阶段执行、但是实践中，他们并不是完全串行的，它
们之间更多时候是交叉进行的，更多的是迭代执行
把测试活动完全独立出来，形成一个完全独立的流程，将测试准备活动和测试执行活动清晰地
体现出来

H模型：
```
测试准备->测试就绪点->测试执行->测试流程
```

H模型的优缺点：
```
优点：
软件测试完全独立，贯穿整个生命周期，且与其他流程并发进行
软件测试活动可以尽早准备、尽早执行，具有很强的灵活性

缺点：
测试就绪点分析困难
对于整个项目组的人员要求非常高
```

3. 软件测试工作流程
传统测试流程：
单元测试->集成测试->冒烟测试->系统测试->回归测试->验收测试

系统测试流程：
需求分析->测试计划->测试设计->用例评审->测试执行->bug管理->发布维护

4. 测试左移和测试右移
- 测试左移：
左移是往测试之前的开发阶段移
测试团队在软件开发周期早期就开始介入
对代码进行测试
从发现bug到预防bug

测试左移-质量保障手段
代码评审
代码审计
单元测试
自动化冒烟测试
研发自测

- 测试右移：
右移是往发布之后移
产品上线后进行线上监控

测试右移-线上监控
闭环的线上问题反馈-检查-解决-更新流程
更便捷的日志查看、回传服务
丰富有效的log，便于问题的快速定位
丰富的监控指标（例如业务异常点指标）
业务监控（例如短信发送等）
关键指标每日监控（服务器指标）
生产数据监控（警报）

## 7. 测试技术体系
1. 软件测试分类

软件测试分类
- 按开发阶段分类
```
单元测试
集成测试
系统测试
	功能测试
	兼容性测试
	性能测试
	安全测试
验收测试 
	α测试
	β测试
```

- 按是否查看代码
白盒测试
```
研究产品内部的源代码和程序结构
单元测试就是白盒测试的一种
```
黑盒测试
```
又称数据驱动测试
完全不考虑程序内部结构和内部特性
注重于测试软件的功能需求
只关心软件的输入数据和输出数据
```
灰盒测试

- 按测试执行方式
静态测试
动态测试

- 按是否手工执行划分
手工测试
自动化测试

- 其它分类
冒烟测试
回归测试
随机测试
探索性测试

2. 分层测试体系
自动化分层测试体系：70%单元测试，20%服务测试，10%用户界面测试
单元测试：
Java: JUnit\TestNG
Python: unittest\pytest 

接口测试：
接口全称Application Programming Interface，一般称作API
是针对软件对外提供服务的接口的输入输出进行测试
检查接口此参数传递的正确性，接口功能实现的正确性，输出结果的正确性，以及
对各种异常情况的容错处理的完整性和合理性

接口测试方法：
```
Charles、Fiddler
postman
Jmeter
loadRunner
python: Requests、HttpRunner
Java: HttpClient、RestAssured
```

UI测试：
手工方法：人工查看、操作
自动化方法：web: selenium;app: appium

## 8. 常用测试平台
测试用例管理与bug管理平台
```
jira: 推荐方案，定制性很强
redmine: 推荐方案，开源，活跃，定制性很强
testlink: 流行的测试用例管理平台，体验不太好
其他: tapd、云效、禅道、gitlab、在线协作文档
无协作模式: excel、思维导图 
```

bug管理平台
通常与用例管理平台一致
测试用例、bug都可以使用issue表达
关联关系设定
测试用例与bug的属性设定

代码管理平台
```
gitlab: 可本地部署的git代码管理平台，行业标准
subversion: svn管理，已经过时
github: 开源项目运作
bitbucket: 与jira同属一家公司altassian
```

持续集成管理平台
```
jenkins: 持续集成与持续交付的主流平台
gitlab runner: gitlab的持续交付方案
github action: github的开源方案
自建devops平台: 企业定制平台，tapd、云效等
```

持续集成与持续交付
```
1. 研发
	构建、单元测试+覆盖率分析
	自动化代码审计
2. 运维
	自动化部署
3. 测试
	接口测试
	UI自动化测试
	专项测试自动化
	性能测试、安全测试
```

## 9. 黑盒测试-边界值
- 大量的软件测试实践表明，故障往往出现在定义域或值域的边界上，而不是在其内部
- 为检测边界附近的处理专门设计测试用例，通常都会取得很好的测试效果
- 边界值分析法是一种很实用的黑盒测试用例方法，它具有很强的发现故障的能力
- 边界值分析法是作为对等价类划分法的补充，测试用例来自等价类的边界

边界值确定
```
上点：边界上的点
离点：离上点最近的点
内点：在输入域内任意一个点
选取正好等于、刚好大于或刚好小于边界值作为测试数据
```

## 10. 黑盒测试-等价类
- 不需要考虑程序的内部结构，只需要考虑程序的输入规格即可
- 它将不能穷举的测试过程进行合理分类，从而保证设计出来的测试用例具有完整性和代表性
- 用户所有可能输入的数据，划分成了若干个子集，然后从每一个子集当中选取少数具有代表性的数据作为测试用例
- 在有限的测试资源的情况下，用少量有代表性的数据得到比较好的测试效果

等价类划分
有效等价类：指符合《需求文档》，输入合理的数据集合
无效等价类：指不符合《需求文档》，输入不合理的数据集合

等价类划分原则
```
1. 规定输入的取值范围或个数时，划分一个有效和两个无效
2. 规定了输入的集合或规则必须要遵循的条件，则划分一个有效和一个无效
3. 输入条件是一个布尔值，则划分为一个有效和一个无效
4. 输入条件是一组数据，并且每一个输入的值做不同的处理，则划分若干个有效和一个无效
5. 输入条件规定了必须要遵循的某些规则下，则划分为一个有效和若干个无效
6. 不是所有的等价类都有无效等价类
```

等价类设计步骤
```
1. 先划分等价类：找出所有可能的分类
2. 确定有效等价类：需求中的条件
3. 确定无效等价类：与条件相反的情况，再找到特殊情况
4. 从各个分类中挑选测试用例数据
```

等价类总结
```
长度
类型
组成规则
是否为空
是否重复
是否去除空格
```

## 11. 黑盒测试-因果图
描述多种条件的组合；产生多个动作。

因果图是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法。
它适合于检查程序输入条件的各种组合情况
“因”--输入条件，“果”--输出结果

1. 因果图中的基本符号
![avatar](https://pic2.zhimg.com/80/v2-2da482783a71fb778f168bab5d86b6b1_1440w.jpg)
- 恒等：若原因出现，则结果出现；若原因不出现，则结果也不出现 
- 非：若原因出现，则结果不出现；若原因不出现，则结果出现
- 或：有多个原因。若几个原因中有一个出现，则结果出现；若几个原因都不出现，
则结果不出现
- 与：有多个原因。若几个原因都不出现，则结果才出现；若其中一个原因不出现，则结果不出现

2. 因果图中的约束条件 
![avatar](https://pic2.zhimg.com/80/v2-2da482783a71fb778f168bab5d86b6b1_1440w.jpg)
- 互斥E：a、b、c只能有一个成立，但是可以都不成立 
- 包含I：a、b、c中至少有一个成立
- 唯一O：a、b、c有且仅有一个成立
- 要求R：如果a成立，则要求b必须也成立，其他的不约束
- 屏蔽M：如果a成立的时候，强制b不成立，其他的不约束 

3. 因果图法基本步骤
- 找出所有的输入条件（因）
- 找出所有的输出条件（果）
- 明确所有输入条件之间的制约关系以及组合关系
- 明确所有输出条件之间的制约关系以及组合关系
- 找出什么样的输入条件会产生哪种输出结果
- 把因果图转换成判定表
- 为判定表中的每一列表示的情况设计测试用例

## 12. 黑盒测试-场景法
场景法就是模拟用户操作软件时的场景，主要用于测试系统的业务流程
基本流：按照正确的业务流程来实现的一条操作路径
备选流：导致程序出现错误的操作流程

场景法用例设计步骤
- 根据需求规格说明，画出功能模块流程图
- 根据流程图，描述出程序的基本流及备选流
- 根据基本流和备选流生成不同的场景，构造场景列表
- 对每一个场景生成相应的测试用例
- 对生成的所有测试用例重新复审，去掉多余的测试用例
- 测试用例确定后，为每一个测试用例确定测试数据值

## 13. 黑盒测试方法论-判定表
因果图只是一种辅助工具，通过分析最终得到判定表，再通过判定表编写测试用例
画因果图非常麻烦，影响测试效率，可以直接写判定表，进而编写测试用例

判定表的组成
```
条件桩：问题的所有条件
动作桩：问题的所有输出
条件项：针对条件桩的取值
动作项：条件项的各种取值情况下的输出结果
```

判定表设计步骤
```
1. 列出所有的条件桩和动作桩
2. 确定规则数：条件取值个数^条件数
3. 输入条件项
4. 填入动作项，得到初始判定表
5. 简化判定表
```

## 14. 黑盒测试方法论-基于模型的测试

## 15. 白盒测试方法
根据待测产品的内部实现细节来设计测试用例
白盒测试的执行手段是可以涵盖单元测试、集成测试
使用代码覆盖率作为白盒测试的主要度量指标

代码覆盖率常见概念：
```
语句覆盖：每行代码都要覆盖至少一次
判定覆盖：判定表达式的真假至少覆盖一次
判定/条件覆盖：判定覆盖与条件覆盖都必须覆盖
条件组合覆盖：判定表达式中的所有条件组合都需要覆盖
分支覆盖：控制流中的每条边都要被覆盖一次
路径覆盖：所有的路径都要尽量覆盖
指令覆盖：一行代码会被编译为多条指令，尽可能的覆盖所有指令
方法覆盖：每个方法至少要被覆盖一次
类覆盖：每个类至少被覆盖一次
```

覆盖率统计的工具
emma、cobertura、jacoco

插桩原理
- 对jvm的字节码插桩
- 基于block插桩
- 计算覆盖的代码块

流程覆盖
```
利用代码执行流代表流程
流程覆盖用路径覆盖率表达
对流程进行裁剪获得一个适合业务的小规模的业务子集
流程覆盖率=测试经过的路径/业务子集路径
```

精准化测试
```
代码调用链与黑盒测试用例的关联
根据代码变更自动分析影响范围
黑盒测试过程中借助代码流程覆盖数据指导探索式测试
利用线上数据推到有效测试用例
代码流程分析与覆盖率统计
```

## 16. 常用测试策略与测试手段
1. 测试策略
在特定环境约束之下，描述软件开发周期中关于测试原则、方法、方式的纲要，并阐述了
它们之间如何配合，以高效地减少缺陷、提升质量。

测试策略的关注重点：
```
1. 测试的目标是什么？
2. 测试可能存在的风险是什么？
3. 测试的对象和范围是什么？
4. 如何安排各种测试活动？
5. 如何评价测试的效果？
```

2. 测试手段
```
黑盒测试
白盒测试
动态测试
静态测试
手工测试
自动化测试
```

## 17. bug定位
| 维度 | 介绍 |
| --- | --- |
| 功能 | 业务流程是否正确 |
| 性能 | 业务流程是否顺畅 |
| 安全 | 是否符合安全标准与规范 |
| 专项质量 | 用户体验、UX兼容性、稳定性、可靠性 |

为什么需要掌握bug定位
提交bug时候追加更多有用信息，方便研发更快的解决问题
分析bug形成原因，进行溯源并建立特征进行批量追踪

bug展现层
条件：测试数据
过程：测试步骤
结果：测试结果

技术架构层次
1.视图层View：
- web UI html css
- app activity view
2.控制器层Controller：
- web: Chrome、devtool
- app: dalvik art object-runtime
3.模型层Model：
- 模型的传递方式 http tcp rpc串口
- 模型的形式 json xml binary
- 模型定义 schema

MVC三层分析方法
- View层：运行平台、应用调试机制、链路分析
- Controller层：运行平台、应用调试机制、链路分析
- Model层：运行平台、应用调试机制、链路分析

View层常用分析方法：
- UI人工测试 自动化测试
- UE人工测试 自动化测试
- UI Diff自动化分析
Controller层常用分析方法
- 运行平台日志：log
- 应用调试日志：debug trace hook profile
Model层常用分析方法：
- 运行平台log
- app调试机制
- 链路分析：代理抓包 嗅探抓包

web view层分析方法
- Chrome dev tool

web model层分析方法：分析数据传递方式与结构
- 运行平台log 
	Chrome network
- 链路分析
	代理proxy: fiddler charles mitmproxy
	网络层协议network: tcpdump wireshark

app view层bug分析
- UI界面交互
- UX/UE用户体验
- UI Diff：uiautomator dump
app controller层分析
- 通过logcat分析app runtime日志
app model层分析方法
- 运行平台log
- 应用：应用日志
- 链路分析：
	代理抓包：charles fiddler mitmproxy
	嗅探抓包：wireshark tcpdump

性能Bug分析方法

**总结**
- 明确bug问题的现象与复现步骤
- 分层分析关键过程的数据与问题特征
- 积累bug特征与问题根源特征，丰富测试经验，提高bug发现的能力

## 18. 测试环境搭建
被测系统AUT(Application Under Test)
移动端测试：用户（Android App\iOS App\H5\微信小程序）
服务端测试：网关->微服务集群（依赖服务集群\大数据计算架构\数据库等存储）

常见的被测系统类型
- UI: Web App IOT
- Service:
	RESTful: spring boot
	webservice
	rpc: dubbo pb
- code: SDK lib

部署方法：
- 打包部署：apk app ipa jar war
- 脚本部署：自动化脚本与自动化平台
- 容器部署：基于容器镜像docker k8s

打包部署：
```
Android: gradle
iOS: xcode xcodebuild
自动化构建工具
Web: nodejs npm
Service: maven gradle
```

容器部署：
```
自动化构建bash
容器构建docker
容器编排k8s
持续集成jenkins
```

## 19. 经典测试书籍
《全程软件测试》
《探索式测试》
《Google测试之道》
《持续交付》
《不测的秘密》
